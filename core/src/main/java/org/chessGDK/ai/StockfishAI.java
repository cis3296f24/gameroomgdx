package org.chessGDK.ai;

import java.io.*;
import java.lang.ProcessBuilder;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.jar.Attributes;
import java.util.jar.Manifest;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.files.FileHandle;
/**
 * The StockfishAI class uses the Stockfish chess engine for an AI oppenent of varying difficulty.
 * It also sets the starting positions, retrieves best moves, checking legality of moves, detects checkmates.
 * This class communicates with the Stockfish engine using the Universal Chess Interface (UCI) protocol.
 */
public class StockfishAI {
    // Fields

    /**
     * The process instance for the Stockfish engine.
     */
    private final Process stockfishProcess;

    /**
     *  Reads the output generated by the Stockfish engine.
     */
    private final BufferedReader input;
    /**
     * Sends commands to the Stockfish engine.
     */
    private final BufferedWriter output;
    /**
     * How far Stockfish searches for computing moves.
     */
    private final int depth;
    /**
     * The difficulty level of the AI opponent.
     */
    private int difficulty = 0;
    /**
     * The current board state in FEN format showing the position of every piece on the board.
     */
    private String FEN;
    /**
     * A list to store responses from the Stockfish engine.
     */
    private List<String> returnList;
    // Constructor

    /**
     * Constructor for StockfishAI which initializes communication with the Stockfish engine.
     *
     * @param depth The depth for AI's move calculations.
     * @param difficulty The difficulty level of the AI.
     * @param fen The initial board state in FEN format.
     */
    public StockfishAI(int depth, int difficulty, String fen) throws IOException {
        String path = System.getProperty("assets.path");
        this.depth = depth;
        returnList = new ArrayList<String>();
        if (path == null) {
            path = getPathForJar(path);
        }
        System.out.println("Root Path: " + path);
        //FileHandle stockfishHandle = Gdx.files.local(path + "stockfish/stockfish-windows-x86-64-avx2.exe");
        FileHandle stockfishHandle = Gdx.files.local("C:/Users/buera/IdeaProjects/gameroomgdx/assets/stockfish/stockfish-windows-x86-64-avx2.exe");

        ProcessBuilder processBuilder = new ProcessBuilder(stockfishHandle.path());
        stockfishProcess = processBuilder.start();
        // Sets input and output
        input = new BufferedReader(new InputStreamReader(stockfishProcess.getInputStream()));
        output = new BufferedWriter(new OutputStreamWriter(stockfishProcess.getOutputStream()));

        sendCommand("uci");
        this.difficulty = difficulty;
        if (difficulty >= 0)
            setDifficulty();
        waitForResponse();
        System.out.println("Stockfish: Universal Chess Interface - initialized");
        setPosition(fen);
        // Close streams and process when done
    }
    // Methods

    /**
     * Retrieves the path for the assets folder from the JAR manifest file.
     *
     * @param path The initial path to be adjusted.
     * @return The path to the assets folder as defined in the manifest file.
     */
    private static String getPathForJar(String path) {
        try {
            // Locate and open the manifest file in the JAR
            InputStream manifestStream = StockfishAI.class.getResourceAsStream("/META-INF/MANIFEST.MF");
            if (manifestStream != null) {
                Manifest manifest = new Manifest(manifestStream);
                Attributes attributes = manifest.getMainAttributes();

                // Retrieve the "Asset-Path" property or any other property you defined
                path = attributes.getValue("Root-Path");
                System.out.println("Root Path from Manifest: " + path);
            } else {
                System.err.println("Manifest not found in JAR.");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return path;
    }


    // Send a command to Stockfish will add newline before sending
    /**
     * Sends a command to the Stockfish engine.
     *
     * @param command The command to send.
     * @return true if the command was sent successfully; false otherwise.
     */

    private boolean sendCommand(String command) {
        returnList.clear();
        //System.out.println("Command sent: " + command);
        if (!stockfishProcess.isAlive()) {
            System.out.println("Stockfish process is dead");
            return false;
        }
        try {
            output.write(command + "\n");
            output.flush();
        } catch (IOException e) {
            System.out.println("Error writing to Stockfish: " + e.getMessage());
        }
        return true;
        //System.out.println("command sent :" + command);
    }
    /**
     * Reads a single line from the Stockfish engine's output.
     *
     * @return The line read from Stockfish, or null if an error occurs.
     */
    private String getLine() {
        String line = null;
        try {
            line = input.readLine();
            if (line == null)
                return null;
            returnList.add(line);
        } catch (IOException e) {
            System.out.println("Error reading from Stockfish: " + e.getMessage());
        }
        return line;
    }
    /**
     * Sets the AI difficulty level by sending a command to Stockfish.
     */
    private void setDifficulty() {
        String command = "setoption name Skill Level value " + difficulty;
        sendCommand(command);
    }
    /**
     * Sets the board position in Stockfish using FEN or "startpos".
     *
     * @param fen The position in FEN format or "startpos".
     */
    private void setPosition(String fen) {
        if (fen.contains("startpos"))
            sendCommand(fen);
        else
            sendCommand("position fen " + fen);
        updateFEN();
    }
    /**
     * Sets the board position in Stockfish using FEN or "startpos".
     *
     * @param fen The position in FEN format or "startpos".
     */
    public void sendPosition(String fen) {
        setPosition(fen);
    }

    /**
     * Waits for Stockfish's response to a command.
     * Ends when "uciok" or "readyok" is detected.
     */

    // Wait for Stockfish's response
    private void waitForResponse(){
        String line;
        while ((line = getLine()) != null) {
            System.out.println(line);
            if (line.contains("uciok") || line.contains("readyok")) {
                break;
            }
        }
    }

    /**
     * Parses through stockfish output to find the first and second best move.
     *
     * @return A string array where the first element is the best move and the second is the ponder move.
     */
    private String[] readMove(){
        String[] moves = {"", ""};
        String line;
        while ((line = getLine()) != null) {
            //System.out.println("Stockfish: " + line);
            if (line.startsWith("bestmove")) {
                moves[0] = line.split(" ")[1];  // Extract the move from the response
                if (line.split(" ").length > 2)
                    moves[1] = line.split(" ")[3];
                break;
            }
        }
        return moves;
    }
    /**
     * Checks if the current position is a checkmate.
     *
     * @return true if the position is a checkmate; false otherwise.
     */
    public boolean checkmate() throws IOException {
        //setPosition(fen);
        // Request the best move
        String toSend = "go movetime 10";
        sendCommand(toSend);
        String[] moves = readMove();
        return moves[0].equalsIgnoreCase("(none)");
    }

    public String getFEN() {
        return FEN;
    }

    /**
     * Updates the internal FEN representation to match the current board state in Stockfish with "d" command.
     */
    public void updateFEN() {
        sendCommand("d");
        String line;
        while ((line = getLine()) != null) {
            if(line.startsWith("Fen: ")) {
                FEN = line.substring(5);
                System.out.println(FEN);
                break;
            }
        }
    }
    /**
     * Reads the best move from "go movetime 400 command".
     *
     * @return A String array of the first and second best move
     */
    public String[] getBestMove(){
        String toSend = "go movetime 400";
        sendCommand(toSend);
        return readMove();
    }


    public String[] getBestMove(String fen){
        // Send the position in FEN format
        String toSend = fen;
        setPosition(toSend);
        // Request the best move
        toSend = "go movetime 400";
        sendCommand(toSend);

        // Read the response until we find the best move
        return readMove();  // Return the best move found
    }
    /**
     * Retrieves all legal moves for the current position using perft command.
     *
     * @return A comma-separated string of all legal moves.
     */

    public String getLegalMoves(){
        // Send the position in FEN format
        // Request the perft command with depth 1
        sendCommand("go perft 1");

        String line;
        StringBuilder legalMoves = new StringBuilder();
        // Read Stockfish's response
        while ((line = getLine()) != null) {
            //System.out.println("Stockfish: " + line);
            // Break on a stopping point to avoid infinite loops
            if (line.startsWith("Nodes searched")) {
                break;
            }
            // Look for the "Legal moves:" line
            if (line.endsWith(": 1")) {
                line = line.substring(0,4);
                legalMoves.append(line).append(","); // Extract moves
                //System.out.println(legalMoves);
            }


        }
        sendCommand("stop");
        return legalMoves.toString();
    }
    /**
     * Verifies if a specific move is legal by checking against a list of legal moves.
     *
     * @param move The move to verify.
     * @param legalMoves A comma separated string of legal moves.
     * @return true if the move is legal; false otherwise.
     */
    public boolean parseLegalMoves(String move, String legalMoves){
        String[] MoveArray = legalMoves.split(",");
        System.out.println(Arrays.toString(MoveArray));
        return Arrays.asList(MoveArray).contains(move);
    }

    public void printBoard() {
        sendCommand("d");
        String line;
        while ((line = getLine()) != null) {
            System.out.println(line);
        }
    }
    /**
     * Terminates the Stockfish process.
     *
     */
    public void close() throws IOException {
        try {
            if (input != null) {
                input.close();
            }
            if (output != null) {
                output.close();
            }
            if (stockfishProcess != null) {
                stockfishProcess.destroy();  // Terminate the Stockfish process
            }
            System.out.println("Stockfish closed");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
